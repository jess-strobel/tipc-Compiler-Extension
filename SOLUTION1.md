CS 4620 Project Deliverable 1: Parsing SIP
Brian Lai and Jess Strobel

One difficult part about implementing the new aspects of the grammar was determining how to treat increment and decrement in the TIP.g4 file. We initially represented each as an expr before changing them to statements.

Our approach to extending the parser was to begin by implementing the new aspects of the grammar that were most similar to the existing grammar. We began by implementing the remaining relational operators ('<', '<=', '>='). This way, we could use the existing grammar as a guide for how to add new features to TIP.g4. As we became more familiar with the parser, we were able to implement more difficult parts of the grammar (like increment and decrement). Initially, we considered incorporating more-strict type-checking for certain statements such as iterator-style and range-style for loops, which require specific types for each expr that they contain to be valid. However, we realized that replacing expr to fully enforce type-checking in our parser rules would be more difficult, prone to error, and sometimes even impossible. As such, this was a design alternative that we avoided, and we instead opted to handle type-checking in future deliverables. The concept of not having to type check in this deliverable also made for a tricky aspect to our solution to handle when testing, as code would only have to be lexically and syntactically correct to match the expected behavior, and not also semantically correct. This will change as we implement more of the compiler for future deliverables.

To test the extended functionality of the parser, we wrote tests targeting both lexical and syntactic errors. Tests ensuring lexically correct programs focused on if newly added tokens (such as 'and' and '<') were recognized as valid, but tokens not represented in the grammar (such as 'aand' and '<<<<') were recognized as invalid. Similarly, tests ensuring syntactically correct programs focused on accepting the correct structure for implementing the new aspects of the grammar (such as 'x = true' and 'y < x') while making sure that programs with an incorrect structure (such as '1 = true' and '< x') were rejected.